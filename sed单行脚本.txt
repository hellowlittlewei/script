

文本分隔：－－－－－－
# 在每一行后面增加一空行。　sed G
# 在每一行后面增加两行空行。　sed "G;G"
# 删除文本中所有的空行。sed "/^$/d"
# 将原来的所有空行删除并在每一行后面增加一空行。sed "/^$/d;G"   这样在输出的文本中每一行后面将有且只有一空行。
# 将第一个脚本所产生的所有空行删除(即删除所有偶数行)。　sed "n;d"  在sed中用n表示奇数行，用p表示偶数行。
# 在每5行后增加一空白行 (在第5，10，15，20，等行后增加一空白行)。sed "n;n;n;n;G;"

# 在包含“regex”的行之前插入一空行。　sed "/regex/{x;p;x;}"  #插入两个空行sed "/regex/{x;p;p;x;}"
# 在包含“regex”的行之后插入一空行。　sed "/regex/G"       　#插入两个空行sed "/regex/{G;G;}"
# 在包含“regex”的行之前和之后各插入一空行。　sed "/regex/{x;p;x;G;}"   #各插入两个空行sed "/regex/{x;p;p;x;G;G;}"


编号：－－－－－－
# 为文件中的每一行进行编号(简单的左对齐方式)。使用“制表符”对齐边缘。　sed = filename | sed "N;s/\n/\t/"
# 对文件中的所有行编号(行号在左，文字右端对齐)。　sed = filename | sed "N; s/^/     /; s/ *\(.\{6,\}\)\n/\1  /"
# 对文件中的所有行编号，不含空白行。　sed "/./=" filename | sed "/./N; s/\n/ /"
# 对文件中的所有行编号，并加上":" ，含空白行。 sed "/./=" filename |sed "/./N; s/\n/:/"
# 计算行数 (模拟 "wc -l")。　sed -n "$="



文本转换和替代：－－－－－－

# 替换每一行中的“foo”都换成“bar”。          sed "s/foo/bar/g"
# 替换每一行中的第一个“foo”字串为“bar”。　　sed "s/foo/bar/"               
# 替换每一行中的第四个“foo”字串为“bar”。    sed "s/foo/bar/4"
# 替换倒数第二个“foo”字串为“bar”。          sed "s/\(.*\)foo\(.*foo\)/\1bar\2/"
# 替换最后一个“foo” 字串为“bar”。           sed "s/\(.*\)foo/\1bar/"
# 只在行中出现字串“baz”的情况下将“foo”替换成“bar”。　sed "/baz/s/foo/bar/g"
# 行中未出现字串“baz”的情况下将“foo”替换成“bar”。　sed "/baz/!s/foo/bar/g"

# 将文本中第1-3行中第三个"a"替换为"b"。　　   sed "1,3s/a/b/3"
# 将文本中第3-5行中第一、三个"a"替换为"b"。   sed -e "3,5s/a/b/1" -e "3,5s/a/b/3"
# 除了第四行外将所有行的第二个"a"替换为"b"。  sed "4!s/a/b/2"

# 不管是“scarlet”“ruby”还是“puce”，一律换成“red”。sed "s/scarlet/red/g;s/ruby/red/g;s/puce/red/g"

# 将每一行前导的“空白字符”(空格，制表符)删除使之左对齐。　sed "s/^[ \t]*//" 
# 将每一行拖尾的“空白字符”(空格，制表符)删除。　sed "s/[ \t]*$//"       
# 将每一行中的前导和拖尾的空白字符删除。　sed "s/^[ \t]*//;s/[ \t]*$//"
# 在行首插入字符(含空格)。           sed "s/^/bathome/"
# 在行首插入“header”，在行尾插入“footer”。 sed 's/^\(.*\)$/header\1 footer/'

# 在每一行开头处插入5个空格(使全文向右移动5个字符的位置)。　sed "s/^/     /"
# 以79个字符为宽度，将所有文本右对齐。　sed -e :a -e "s/^.\{1,78\}$/ &/;ta"    # 78个字符外加最后的一个空格
# 以79个字符为宽度，使所有文本居中。在方法1中，为了让文本居中每一行的前头和后头都填充了空格。 在方法2中，在居中文本的过程中只在文本的前面填充空格，并且最终这些空格将有一半会被删除。此外每一行的后头并未填充空格。
sed  -e :a -e "s/^.\{1,77\}$/ & /;ta"                     # 方法1
sed  -e :a -e "s/^.\{1,77\}$/ &/;ta" -e "s/\( *\)\1/\1/"  # 方法2

# 所有以http://开头的行都会被替换成它自已加192.168.0.1，变成http://192.168.0.1localhost。sed "s/^http\:\/\//&192.168.0.1/"   &符号表示替换换字符串中被找到的部份。
# love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。  sed -n "s/\(love\)able/\1rs/p"
# 不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。 sed "s#10#100#g"
# 对于模板test和west之间的行，每行的末尾用字符串sed test替换。 sed "/test/,/check/s/$/sed test/"
# 用"pause"来取代第5－－－－－－8行所有的内容(非每行)。 sed "5,8c\pause"  c开关是sed中用用户输入内容来取代原本内容的，其后紧跟"\"，用这种方法同样可以将指定行替换为空行(并不是严格意义上的空行，至少有一个空格)

# 倒置所有行，第一行成为最后一行，依次类推(模拟“tac”)。由于某些原因，使用下面命令时HHsed v1.5会将文件中的空行删除
sed "1!G;h;$!d"               # 方法1
sed -n "1!G;h;$p"             # 方法2

# 将行中的字符逆序排列，第一个字成为最后一字，……(模拟“rev”)。　sed "/\n/!G;s/\(.\)\(.*\n\)/&\2\1/;//D;s/.//"
# 将文件中包含的字符串(本例为“they”)中的4个字按4132顺序变换(变为yteh)。sed "s/\(t\)\(h\)\(e\)\(y\)/\4\1\3\2/"

# 将每两行连接成一行(类似“paste”)。　sed "$!N;s/\n/ /"
# 如果当前行以反斜杠“\”结束，则将下一行并到当前行末尾并去掉原来行尾的反斜杠。　sed -e :a -e "/\\$/N; s/\\\n//; ta"
# 如果当前行以等号开头，将当前行并到上一行末尾并以单个空格代替原来行头的“=”。　sed -e :a -e "$!N;s/\n=/ /;ta" -e "P;D"

# 为数字字串增加逗号分隔符号，将“1234567”改为“1,234,567”。sed -e :a -e "s/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta"  # 其他sed
# 为带有小数点和负号的数值增加逗号分隔符(GNU sed)gsed -r ":a;s/(^|[^0-9.])([0-9]+)([0-9]{3})/\1\2,\3/g;ta"




选择性地显示特定行：－－－－－－

# 只显示匹配正则表达式的行(模拟“grep”)。sed -n "/regexp/p"  # 方法1　　sed "/regexp/!d" # 方法2
# 只显示不包含正则表达式的行。sed -n "/regexp/!p" # 方法1，与前面的命令相对应。sed "/regexp/d"  # 方法2，类似的语法
# 显示匹配或发生的行。sed -n "s/^test/mytest/p"  -n开关是表示输出由编辑指令控制，p开关是有条件显示开关。

# 显示从包含正则表达式的行开始到最后一行结束。　sed -n "/regexp/,$p"
# 显示通篇文档，除了两个正则表达式之间的内容。　sed "/start/,/end/d"　

# 显示两个正则表达式之间的文本(包含)。　sed -n "/start/,/end/p"   # 区分大小写方式
# 显示从第五行开始到第一个包含以test开始的行之间的所有行。sed -n "5,/^test/p"

# 查找“regexp”并将匹配行的上一行显示出来，但并不显示匹配行。　sed -n "/regexp/{g;1!p;};h"
# 查找“regexp”并将匹配行的下一行显示出来，但并不显示匹配行。　sed -n "/regexp/{n;p;}"
# 显示包含“regexp”的行及其前后行，并在第一行之前加上“regexp”所在行的行号 (类似“grep -A1 -B1”)。　sed -n -e "/regexp/{=;x;1!p;g;$!N;p;D;}" -e h

# 显示既包“AAA”“BBB”“CCC”的行(任意次序)。　sed "/AAA/!d; /BBB/!d; /CCC/!d"  # 字串的次序不影响结果
# 显示包含“AAA”、“BBB”和“CCC”的行(固定次序)。　sed "/AAA.*BBB.*CCC/!d"
# 显示包含“AAA”“BBB”“CCC”任一字符串的行 (模拟“egrep”)　sed -e "/AAA/b" -e "/BBB/b" -e "/CCC/b" -e d    # 多数sed

# 显示包含“AAA”的段落 (段落间以空行分隔)HHsed v1.5 必须在“x;”后加入“G;”，接下来的3个脚本都是这样。　sed -e "/./{H;$!d;}" -e "x;/AAA/!d;"
# 显示包含“AAA”“BBB”和“CCC”三个字串的段落 (任意次序)。　sed -e "/./{H;$!d;}" -e "x;/AAA/!d;/BBB/!d;/CCC/!d"
# 显示包含“AAA”、“BBB”、“CCC”三者中任一字串的段落 (任意次序)。sed -e "/./{H;$!d;}" -e "x;/AAA/b" -e "/BBB/b" -e "/CCC/b" -e d

# 显示指定行号范围(从第8至第12行，含8和12行)。sed -n "8,12p" # 方法1　sed "8,12!d"　# 方法2
# 显示第52行。sed -n "52p"  # 方法1　　　sed "52!d" # 方法2　　　sed "52q;d" # 方法3, 处理大文件时更有效率
# 从第3行开始，每7行显示一次   sed -n "3,${p;n;n;n;n;n;n;}"
# 不显示文本中前10行。　　sed 1,10d
# 显示文本的奇数行(含空行)。sed -n -e "p" -e "n"  在sed中用n表示奇数行，用p表示偶数行。
# 显示文本的偶数行(含空行)。sed -n -e "n" -e "p"
# 显示3的倍数行。           sed -n "n;n;p" 先用n开关将输出定向到编辑指令，然后输入法3-1个n;最后用显示开关p结尾，也就时说3前的数字的倍数行不显示，只显示3的倍数行。
# 显示文件中的前10行 (模拟“head”的行为)。　sed 10q
# 显示文件中的第一行 (模拟“head -1”命令)。　sed q
# 显示文件中的最后10行 (模拟“tail”)。　sed -e :a -e "$q;N;11,$D;ba"
# 显示文件中的最后2行(模拟“tail -2”命令)。　sed "$!N;$!D"
# 显示文件中的最后一行(模拟“tail -1”)。sed "$!d"   # 方法1　sed -n "$p" # 方法2
# 显示文件中的倒数第二行
sed -e "$!{h;d;}" -e x              # 当文件中只有一行时，输入空行
sed -e "1{$q;}" -e "$!{h;d;}" -e x  # 当文件中只有一行时，显示该行
sed -e "1{$d;}" -e "$!{h;d;}" -e x  # 当文件中只有一行时，不输出

# 显示文本含有数字的行。sed -n "/[0-9]/p"
# 显示文本不含有数字的行。sed "/[0-9]/d"

# 显示包含65个或以上字符的行。　sed -n "/^.\{65\}/p"
# 显示包含65个以下字符的行。sed -n "/^.\{65\}/!p"  # 方法1，与上面的脚本相对应。　sed "/^.\{65\}/d" # 方法2，更简便一点的方法。




选择性地删除特定行：－－－－－－

# 删除匹配式样的行。　sed "/pattern/d"     # 删除含pattern的行。当然pattern可以换成任何有效的正则表达式
# 删除匹配式样以外的行。　sed "/pattern/!d"

# 删除文件中相邻的重复行(模拟“uniq”)只保留重复行中的第一行，其他行删除。　sed "$!N; /^\(.*\)\n\1$/!P; D"
# 删除文件中的重复行，不管有无相邻。　sed -n "G; s/\n/&&/; /^\([ -~]*\n\).*\n\1/d; s/\n//; h; P"
# 删除除重复行外的所有行(模拟“uniq -d”)。　sed "$!N; s/^\(.*\)\n\1$/\1/; t; D"

# 删除文件中开头的10行。　sed "1,10d"
# 删除文件中的最后一行。　sed "$d"
# 删除example文件的第二行。 sed "2d"
# 删除文件中的最后两行。　sed "N;$!P;$!D;$d"
# 删除文件中的最后10行。sed -e :a -e "$d;N;2,10ba" -e "P;D"   # 方法1　　sed -n -e :a -e "1,10!{P;N;D;};N;ba"  # 方法2
# 删除example文件的第二行到末尾所有行。 sed "2,$d" example
# 删除文件中第2行到第一个"write"所在行(含该行)之间的所有内容。 sed "2,/write/d"
# 删除8的倍数行。sed "n;n;n;n;n;n;n;d;"

# 删除文件中的所有空行。sed "/^$/d"  # 方法1　　sed "/./!d"　# 方法2
# 只保留多个相邻空行的第一行。并且删除文件顶部和尾部的空行。(模拟“cat -s”)
sed "/./,/^$/!d"        #方法1，删除文件顶部的空行，允许尾部保留一空行
sed "/^$/N;/\n$/D"      #方法2，允许顶部保留一空行，尾部不留空行
# 只保留多个相邻空行的前两行。　sed "/^$/N;/\n$/N;//D"
# 删除文件顶部的所有空行。　sed "/./,$!d"
# 删除文件尾部的所有空行。　　sed -e :a -e "/^\n*$/{$d;N;ba" -e "}"  # 对所有sed有效

# 删除每个段落的最后一行。　sed -n "/^$/{p;h;};/./{x;/./p;}"

# 删除文本所有行首的四个字符。sed "s/^....//"
# 删除文本所有行尾的四个字符。sed "s/....$//"



多点编辑：e命令 －－－－－－
# (-e)选项允许在同一行里执行多条命令。 sed -e "1,5d" -e "s/test/check/"
# 给sed表达式赋值。  sed --expression="s/test/check/" --expression="/love/d" 一个比-e更好的命令是--expression。



从文件读入：r命令 －－－－－－
#　file里的内容被读进来，显示在与test匹配的行后面。 sed "/test/r file" 如果匹配多行，则file的内容将显示在所有匹配行的下面。



写入文件：w命令 －－－－－－
# 在example中所有包含test的行都被写入file里。 sed -n "/test/w file"



追加命令：a命令 －－－－－－
# 在所有包含test行的下一行插入“newline”行。sed "/test/a\newline"
# 在文本中每一行下插入“newline”行。        sed "a\newline"



插入：i命令 －－－－－－
# 在所有包含test行的上一行插入“newline”行。sed "/test/i\newline"
# 在文本中每一行上面插入“newline”行。      sed "i\newline"



下一个：n命令 －－－－－－
# 如果test被匹配，则将下一行中的aa替换为bb，并打印该行。 sed "/test/{ n; s/aa/bb/; }"　注意：如果连续有三行包含test和aa,只有第二行的aa会被替换。



变形：y命令－－－－－－
将文本中的字母换成大写。sed "y/abcdefg/ABCDEFG/" y开关是sed中真正的变形开关，同理可以将文本中的数字全变成大写数字。
# 把1--10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。 sed "1,10y/abcde/ABCDE/"



退出：q命令 －－－－－－
# 打印完第10行后，退出sed。 sed "10q"



保持和获取：h命令和G命令 －－－－－－
# 在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将 打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保 持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中 的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。 sed -e "/test/h" -e "$G



保持和互换：h命令和x命令 －－－－－－
# 互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。  sed -e "/test/h" -e "/check/x" example -----




特殊应用：－－－－－－
# 移除手册页(man page)中的nroff标记。在Unix System V或bash shell下使用"echo"命令时可能需要加上 -e 选项。
sed "s/.^H//g"             # 在bash或tcsh中, 按 Ctrl-V 再按 Ctrl-H
sed "s/.\x08//g"           # sed 1.5，GNU sed，ssed所使用的十六进制的表示方法
# 提取新闻组或 e-mail 的邮件头。　sed "/^$/q"                # 删除第一行空行后的所有内容
# 提取新闻组或 e-mail 的正文部分。　sed "1,/^$/d"              # 删除第一行空行之前的所有内容
# 从邮件头提取“Subject”(标题栏字段)，并移除开头的“Subject:”字样。　sed "/^Subject: */!d; s///;q"
# 从邮件头获得回复地址。　sed "/^Reply-To:/q; /^From:/h; /./d;g;q"
# 获取邮件地址。在上一个脚本所产生的那一行邮件头的基础上进一步的将非电邮地址的部分剃除。(见上一脚本)。　sed "s/ *(.*)//; s/>.*//; s/.*[:<] *//"
# 在每一行开头加上一个尖括号和空格(引用信息)。　sed "s/^/> /"
# 将每一行开头处的尖括号和空格删除(解除引用)。　sed "s/^> //"
# 移除大部分的HTML标签(包括跨行标签)。　sed -e :a -e "s/<[^>]*>//g;/</N;//ba"
# 将分成多卷的uuencode文件解码。移除文件头信息，只保留uuencode编码部分。文件必须以特定顺序传给sed。下面第一种版本的脚本可以直接在命令行下输入；第二种版本则可以放入一个带执行权限的shell脚本中。(由Rahul Dhesi的一个脚本修改而来。)
sed "/^end/,/^begin/d" file1 file2 ... fileX | uudecode   # vers. 1
sed "/^end/,/^begin/d" "$@" | uudecode                    # vers. 2
# 将文件中的段落以字母顺序排序。段落间以(一行或多行)空行分隔。sed "/./{H;d;};x;s/\n/={NL}=/g" file | sort | sed "1s/={NL}=//;s/={NL}=/\n/g"
# 分别压缩每个.TXT文件，压缩后删除原来的文件并将压缩后的.ZIP文件命名为与原来相同的名字(只是扩展名不同)。(DOS环境：“dir /b”显示不带路径的文件名)。
echo @echo off >zipup.bat
dir /b *.txt | sed "s/^\(.*\)\.TXT/pkzip -mo \1 \1.TXT/" >>zipup.bat


使用SED：Sed接受一个或多个编辑命令，并且每读入一行后就依次应用这些命令。当读入第一行输入后，sed对其应用所有的命令，然后将结果输出。接着再读入第二行输入，对其应用所有的命令……并重复这个过程。上一个例子中sed由标准输入设备(即命令解释器，通常是以管道输入的形式)获得输入。在命令行给出一个或多个文件名作为参数时，这些文件取代标准输入设备成为sed的输入。sed的输出将被送到标准输出(显示器)。因此：

cat filename | sed "10q"         # 使用管道输入
sed "10q" filename               # 同样效果，但不使用管道输入
sed "10q" filename > newfile     # 将输出转移(重定向)到磁盘上


　　括号语法：前面的例子对sed命令基本上都使用单引号("...")而非双引号("...")这是因为sed通常是在Unix平台上使用。单引号下，Unix的shell(命令解释器)不会对美元符($)和后引号(`...`)进行解释和执行。而在双引号下美元符会被展开为变量或参数的值，后引号中的命令被执行并以输出的结果代替后引号中的内容。而在“csh”及其衍生的shell中使用感叹号(!)时需要在其前面加上转义用的反斜杠(就像这样：\!)以保证上面所使用的例子能正常运行(包括使用单引号的情况下)。DOS版本的Sed则一律使用双引号("...")而不是引号来圈起命令。

　　"\t"的用法：为了使本文保持行文简洁，我们在脚本中使用"\t"来表示一个制表符。但是现在大部分版本的sed还不能识别"\t"的简写方式，因此当在命令行中为脚本输入制表符时，你应该直接按TAB键来输入制表符而不是输入"\t"。下列的工具软件都支持"\t"做为一个正则表达式的字元来表示制表符：awk、perl、HHsed、sedmod以及GNUsed v3.02.80。
脚本
Sed脚本是一个sed的命令清单，启动Sed时以-f选项引导脚本文件名。Sed对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行为注释行，且不能跨行。


小技巧
在sed的命令行中引用shell变量时要使用双引号，而不是通常所用的单引号。下面是一个根据name变量的内容来删除named.conf文件中zone段的脚本：

name="zone\ "localhost""sed "/$name/,/};/d" named.conf




###############################################################################################################



1. Sed简介
sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”(pattern space)，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。以下介绍的是Gnu版本的Sed 3.02。


2. 定址
可以通过定址来定位你所希望编辑的行，该地址用数字构成，用逗号分隔的两个行数表示以这两行为起止的行的范围(包括行数表示的那两行)。如1,3表示1,2,3行，美元符号($)表示最后一行。范围可以通过数据，正则表达式或者二者结合的方式确定。


3. Sed命令
调用sed命令有两种形式：
sed [options] "command" file(s)
sed [options] -f scriptfile file(s)

a\　　在当前行后面加入一行文本。
b　　lable　　分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。
c\　　用新的文本改变本行的文本。
d　　从模板块(Pattern　　space)位置删除行。d开关是表示删除的意思。
D　　删除模板块的第一行。
i\　　在当前行上面插入文本。
h　　拷贝模板块的内容到内存中的缓冲区。
H　　追加模板块的内容到内存中的缓冲区
g　　获得内存缓冲区的内容，并替代当前模板块中的文本。
G　　获得内存缓冲区的内容，并追加到当前模板块文本的后面。
l　　列表不能打印字符的清单。
n　　读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。
N　　追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。
p　　打印模板块的行。
P(大写)　　打印模板块的第一行。
q　　退出Sed。
r　　file　　从file中读行。
t　　label　　if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
T　　label　　错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
w　　file　　写并追加模板块到file末尾。
W　　file　　写并追加模板块的第一行到file末尾。
!　　表示后面的命令对所有没有被选定的行发生作用。
s/re/string　　用string替换正则表达式re。
=　　打印当前行号码。
#　　把注释扩展到下一个换行符以前。

以下的是替换标记
g　　表示行内全面替换。
p　　表示打印行。
w　　表示把行写入一个文件。
x　　表示互换模板块中的文本和缓冲区中的文本。
y　　表示把一个字符翻译为另外的字符(但是不用于正则表达式)



4. 选项
-e　　command,　　--expression=command　　允许多台编辑。
-h,　　--help　　打印帮助，并显示bug列表的地址。
-n,　　--quiet,　　--silent　　取消默认输出。
-f,　　--filer=script-file　　引导sed脚本文件名。
-V,　　--version　　打印版本和版权信息。


5. 元字符集
^　　锚定行的开始　　如：/^sed/匹配所有以sed开头的行。
$　　锚定行的结束　　如：/sed$/匹配所有以sed结尾的行。
$p  最后一行
.　　匹配一个非换行符的字符　　如：/s.d/匹配s后接一个任意字符，然后是d。
*　　匹配零或多个字符　　如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。
[]　　匹配一个指定范围内的字符，如/[Ss]ed/匹配sed和Sed。
[^]　　匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。
\(..\)　　保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。
&　　保存搜索字符用来替换其他字符，如s/love/**&**/，love这成**love**。
\<　　锚定单词的开始，如:/\<love/匹配包含以love开头的单词的行。
\>　　锚定单词的结束，如/love\>/匹配包含以love结尾的单词的行。
x\{m\}　　重复字符x，m次，如：/0\{5\}/匹配包含5个o的行。
x\{m,\}　　重复字符x,至少m次，如：/o\{5,\}/匹配至少有5个o的行。
x\{m,n\}　　重复字符x，至少m次，不多于n次，如：/o\{5,10\}/匹配5--10个o的行。


6.执行档案内的编辑指令
当执行的指令太多 , 在命令列上撰写起来十分混乱 , 此时 , 可将这些指令整理储存在档案(譬如档名为 script_file )内 , 用选项 -f script_file , 则让 sed 执行script_file 内的编辑指令。其命令的格示如下 : sed -f script_file 文件档,其中, 执行 script_file 内编辑指令的顺序是由上而下。例如上一节的例子 , 其可改成如下命令: sed -f ysb.scr yel.dat,其中 , ysb.scr 档的内容如下 : 1,10d s/yellow/black/g,另外, 在命令列上可混合使用选项 -e 与 -f , sed 执行指令顺序依然是由命令列的左到右, 如执行至 -f 後档案内的指令 , 则由上而下执行。


7. 执行多个文件档的编辑
在 sed 命令列上 , 一次可执行编辑多个文件档 , 它们跟在编辑指令之後。例如 , 替换white.dat、red.dat、black.dat 档内的 "yellow" 字串成 "blue" , 其命令如下: sed -e 's/yellow/blue/g' white.dat red.dat black.dat,上述命令执行时 , sed 依 white.dat、red.dat、black.dat 顺序 , 执行编辑指令 s/yellow/blue/(请参照[section 4.1] ,进行字串的替换.。

8.执行输出的控制

在命令列上的选项 -n (解[7]) 表示输出由编辑指令控制。由前章内容得知 ,sed 会 "自动的" 将资料由 pattern space 输送到标准输出档。但藉着选项 -n , 可将 sed 这 "自动的" 的动作改成 "被动的" 由它所执行的编辑指令(解[8])来决定结果是否输出。由上述可知 , 选项 -n 必须与编辑指令一起配合 , 否则无法获得结果。
例如 ,印出 white.dat 档内含有 "white"  字串的资料行 , 其命令如下: sed -n -e '/white/p' white.dat
上面命令中 , 选项 -n 与编辑指令 /white/p (参照[section4.6]) 一起配合控制输出。其中 , 选项 -n 将输出控制权移给编辑指;/white/p 将资料行中含有 "white" 字串印出萤幕。 
